### 绘制
在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。

注意：
2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。


3D坐标-> 渲染管线-> 2D 像素

### 相关概念的介绍：


### 渲染管线 Graphics Pipeline
实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程

图形渲染管线可以被划分为两个主要部分：
第一部分把你的3D坐标转换为2D坐标，
第二部分是把2D坐标转变为实际的有颜色的像素。


---
图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入

---------
#### 着色器
所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，
当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，
从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。

有些着色器可以由开发者配置，因为允许用自己写的着色器来代替默认的，所以能够更细致地控制图形渲染管线中的特定部分了。
[因为它们运行在GPU上，所以节省了宝贵的CPU时间]。
OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的


#### 顶点数据
顶点数据是一系列顶点的集合。


#### 渲染管线各阶段  
1. [顶点着色器]：它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。

2. 几何着色器：顶点着色器阶段的输出可以选择性地传递给几何着色器(Geometry Shader)。几何着色器将一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。在这个例子中，它从给定的形状中生成第二个三角形。

3. 图元装配：图元装配(Primitive Assembly)阶段将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状；本节例子中是两个三角形。  

4. 光栅化阶段：会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。

5. [片段着色器]：主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。

6. Alpha测试和混合(Blending):这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃


### 开始绘制三角形

注意事项：
OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；
OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。
所有在这个范围内的坐标叫做标准化设备坐标，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）

标准化设备坐标系z为0的情况：
       0, 1
        |
-1,0---0，0-----1,0
        |
      0,-1

由标准化设备坐标-> 屏幕空间坐标 （作为片段着色器的输入）


#### 技术细化里面到底干了啥？
1.顶点着色器：它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。
  顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点

技术要点：
使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。


---
当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。

