## 1.功能开发：
使用MVC 模式进行开发：
-View及scene 进行UI界面相关逻辑，及用户输入状态发送协议
-Module 管理该功能的状态触发及更新（接收服务器数据，并实时通知View，完成交互）
-Data  对数据进行存储及封装，包含对配表数据进行封装

配表数据加载：采用Dao模式将配表数据对象化提供给Data及外部使用，便于业务逻辑和数据访问代码之间的分离，更加清晰


## 2.战斗开发：
采用【状态机】完成维护整个游戏战斗的开发
Actor 为具体的执行者，Actor有自己的属性、行为和状态,并能独立地做出决策和执行动作。
Agent 是Actor的代理,拥有自己的状态机,用于管理自身的状态及状态切换。
State 状态是状态机中的一个特定状态,如待机状态、追逐状态、攻击状态等。每个状态都包含了该状态下的行为逻辑,如何移动、如何攻击等，在不同的时机完成状态切换。

交互：
接收到用户输入,比如按下攻击键。
玩家角色的状态机接收到这个输入事件,并根据当前状态进行状态切换,比如从待机状态切换到攻击状态。
状态机通知攻击状态(State)执行攻击逻辑,比如播放攻击动画、计算伤害等。
攻击状态在攻击动作完成后,会向状态机反馈当前状态已完成,状态机则切换回待机状态。
玩家角色的 Actor 会执行待机状态下的逻辑,如站立等待下一个用户输入

#### 如：游戏中：角色移动所涉及的状态机逻辑
--如下方：
1.监测输入4种方式：
(1) 摇杆：通过摇杆输入->移动类型（走、跑），移动方向信息 ->让英雄切换
(2) 技能：主要是特定技能，可以选择单一目标区域的技能（Constant.SkillTargetType.ONE_AREA）
(3) 挂机：点击挂机
(4) 点击地图：根据点击目标点格子坐标与当前人物坐标计算出：移动类型、移动方向 ****TODO这个计算的算法可以看看

2.最终都通过发送消息
heroAgent:onMessage({msgId=消息ID, moveType=移动类型（走、跑、不移动）, moveDirection=移动方向（8个）, mNext=下一个格子的横坐标, nNext=下一个格子的纵坐标})

3.发送信息给英雄实体不同的状态
self._stateMachine:onMessage(msg)
可以看出根据英雄当前状态机运行的状态进行处理
例如：
1.HeroStateIdle等待状态：收到移动后：切换到移动状态,给服务器发送移动指令
2.【HeroStateAttack】攻击状态：收到移动指令，并根据传入信息做不同状态切换，
      （1）lt.Constant.MOVE_NONE没移动->切换到等待状态
      （2）移动了->切换到移动状态
3.【HeroStateChase追击】【HeroStateMoveHangup 移动挂机】【HeroStateOverlapMove 移动重叠状态】 等收到都是简单同步一下传递过来的信息，并提供给当前状态的其他需要这个信息的地方使用罢了

### 启动器相关热更新
 热更新：通过比较本地res_map.txt与远端获取的md5文本的md值，不相同则加入下载列表，其中过滤已下载的文件，-->  按照队列依次进行下载->下载相关逻辑封装在cpp层
 如果比较完，没有不同，就跳过更新 

### TODO