# 什么是行为树？
行为树是一个包含逻辑节点和行为节点的树结构，每次需要找出一个行为的时候，会从树的根节点出发，遍历各个节点，找出第一个和当前数据相符合的行为。

# 应用场景
游戏AI

# 通信
一般情况下，我们都会选择存储在与这个行为树绑定的黑板上，也就是行为树对应的数据上下文当中

# 常用节点
基础逻辑节点：
    Selector 选择 
    Sequence 顺序  
    Parallel 并行

自定义行为节点：
   如：攻击，巡逻等
自定义条件节点：
   如：检测血量小于某值，是否找到目标

# 节点状态
Success Fail Running


# 拓展节点介绍
过滤器（Filter）
过滤器，由顺序器改造而来，就是在进入子节点之前，加了些条件判断，如果不满足任意一个，就不能执行后续的子节点，此即为「过滤」。
过滤器-条件1-条件2-条件3-...条件n -节点1-节点2

主动选择器
假设，某人正在砍树，但突然电锯故障了，迫不得已他只能换斧头来砍树；但突然被扔在一旁的电锯又好起来了，那他还会继续费力的用斧子来砍树吗？
我想，只要他还没因为中暑把CPU干烧就不会这么做。但他如果是一个NPC的话，按照之前「选择器」的逻辑，确实会出现这种荒谬的行为。所以我们需要一个特殊的选择器，能始终执行最具优先级的子节点，甚至可以因此打断正在运行的低优先级的子节点。
我们只需对「选择器」的OnUpdate进行改造，在每次调用时，也从头到尾进行选择（默认高优先级的行为在前面）即可：
```csharp
public class ActiveSelector: Selector
{
    protected override EStatus OnUpdate()
    {
        var prev = currentChild;
        base.OnInitialize();//注意这里，currentChild 会被赋值为 children.First
        var res = base.OnUpdate();//按Selector的OnUpdate执行，顺序遍历选择
        /*
        只要不是遍历结束或可执行节点不变，都应该中断上一次执行的节点，无论优先是高是低。
        因为如果当前优先级比之前的高，理应中断之前的；
        而如果比之前的低，那就证明之前高优先级的行为无法继续了，
        否则怎么会等到现在的低优先级的行为呢？所以也应中断它。
        */
        if(prev != children.Last && currentChild != prev)
            prev.Value.Abort();
        return res;
    }
}
```

监视器
监视器是对「并行器」的改造，改造的目的也是为了能持续检查并行行为的条件。



# 修饰节点
1.取反器
简单地对子节点执行结果的「成功」或「失败」进行颠倒而已，但这小小的功能却能帮我们省去很多冗余的代码，比如有「存在敌人」的条件节点时，再想要「不存在敌人」的条件节点，就不必去写代码了，只需要在「存在敌人」前加上这样一个「取反器」就可以了。
2.重复执行器
重复执行某（些）行为也是常见的动作需求，这些动作往往都是已实现的单一动作，例如，有了「点射」动作，我们就可以仅给它加上一个重复执行器，就可以实现「扫射」。