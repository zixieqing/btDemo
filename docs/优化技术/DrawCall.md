# DrawCall
## 1.DrawCall 是什么？ 为什么要减少drawcall? 如何减少drawcall?
Drawcall 是指 GPU 在一个渲染指令中绘制一组几何体的过程。每个 drawcall 都需要将相关的渲染状态(材质、纹理、变换矩阵等)传输到 GPU,这个过程会消耗大量的 CPU 和 GPU 资源。

为什么要减少 drawcall 数量?

1. 提高渲染性能:
   - 每个 drawcall 都需要设置渲染状态,这会带来一定的开销。
   - 减少 drawcall 数量可以降低 CPU 和 GPU 之间的通信开销,从而提高整体的渲染性能。

2. 优化内存使用:
   - 每个 drawcall 都需要传输相关的渲染数据(顶点、纹理等)到 GPU。
   - 减少 drawcall 数量可以减少内存的使用,降低对内存的需求。

3. 提高合批效率:
   - GPU 渲染时会尝试对相似的 drawcall 进行合批处理,以提高效率。
   - 减少 drawcall 数量可以增加合批的机会,进一步提高渲染性能。

如何减少 drawcall 数量?

1. 使用纹理集合:
   - 将多个小纹理合并到一个大纹理中,这样可以减少纹理切换的 drawcall。

2. 合并几何数据:
   - 尽量将几何数据相似的 UI 元素合并到一个 drawcall 中渲染。
   - 这需要保持几何数据(顶点、纹理坐标等)的连续性。

3. 减少状态切换:
   - 尽量使用相同的渲染状态(材质、混合模式等)来渲染 UI 元素。
   - 这样可以减少状态切换的 drawcall。

4. 优化层级结构:
   - 合理规划 UI 元素的层级结构,将使用相同材质的元素放在同一层级上。
   - 这样可以确保渲染顺序的一致性,减少状态切换。

5. 使用批处理:
   - 将多个 UI 元素的渲染数据合并到一个 drawcall 中进行批量处理。
   - 这需要 UI 元素的几何数据和渲染状态保持一致。

总之,减少 drawcall 数量是一个非常重要的性能优化点。通过采取上述措施,可以显著提高游戏的整体渲染性能,为玩家带来更流畅的体验。

### 2.DrawCall 消耗的cpu 还是gpu
Drawcall 的消耗主要体现在 CPU 和 GPU 两个方面:

1. CPU 消耗:
   - 每个 drawcall 都需要 CPU 来设置相关的渲染状态,如材质、纹理、变换矩阵等。
   - 这些状态设置操作会占用 CPU 的计算资源,尤其是在复杂场景中会造成较大的 CPU 开销。

2. GPU 消耗:
   - 每个 drawcall 都需要 GPU 来执行实际的渲染任务,包括顶点处理、光栅化、纹理采样等。
   - 这些渲染任务会占用 GPU 的处理能力,如果 drawcall 过多,可能会导致 GPU 负载过重,从而影响整体的渲染性能。

总的来说,drawcall 的消耗体现在 CPU 和 GPU 两个方面:

- CPU 消耗:主要体现在渲染状态的设置和数据传输过程。
- GPU 消耗:主要体现在实际的渲染任务执行过程。

减少 drawcall 数量可以有效降低 CPU 和 GPU 的负载,从而提高整体的渲染性能。这是一个非常重要的性能优化点,在游戏开发中需要重点关注。

### 3.drawcall 过高会出现什么后果和代价？
Drawcall 过高会带来以下几个主要的后果和代价:

1. 严重影响渲染性能:
   - 每个 drawcall 都需要 CPU 设置渲染状态,并将数据传输到 GPU。
   - 过多的 drawcall 会大幅增加 CPU 和 GPU 之间的通信开销,从而严重拖慢整体的渲染速度。
   - 这会导致游戏帧率下降,给玩家带来卡顿感,影响游戏体验。

2. 加剧内存占用:
   - 每个 drawcall 都需要传输相关的渲染数据(顶点、纹理等)到 GPU。
   - 过多的 drawcall 会大幅增加内存的使用量,尤其在移动设备上可能会耗尽可用内存。
   - 内存占用过高会导致游戏崩溃或卡顿,严重影响游戏稳定性。

3. 降低合批效率:
   - GPU 会尝试对相似的 drawcall 进行合批处理,以提高渲染效率。
   - 但如果 drawcall 过多,GPU 很难找到可以合批的机会,从而降低合批的效率。
   - 这会进一步加剧 CPU 和 GPU 之间的通信开销,拖慢整体的渲染速度。

4. 增加渲染复杂度:
   - 过多的 drawcall 会增加渲染管线的复杂度,导致更多的状态切换和资源绑定操作。
   - 这些额外的操作会进一步消耗 CPU 和 GPU 的资源,降低整体的渲染效率。

综上所述,drawcall 过高会严重影响游戏的整体性能和稳定性,表现为帧率下降、内存占用过高、渲染效率低下等问题。这是游戏开发中需要高度重视的一个性能瓶颈,需要采取各种优化措施来降低 drawcall 的数量。

###### 手机端
是的,在移动设备上,drawcall 过高还会导致设备发烫的问题。这主要体现在以下几个方面:

1. CPU 负载过重:
   - 移动设备的 CPU 性能通常较弱,如果 drawcall 过多会大幅增加 CPU 的负载。
   - 持续高负载会导致 CPU 温度升高,从而引发设备发烫的问题。

2. GPU 负载过重:
   - 移动设备的 GPU 性能也有限,如果 drawcall 过多会大幅增加 GPU 的负载。
   - 持续高负载会导致 GPU 温度升高,从而引发设备发烫的问题。

3. 内存占用过高:
   - 移动设备的内存容量较小,如果 drawcall 过多会大幅增加内存的使用量。
   - 内存占用过高会导致系统频繁进行内存交换,从而增加 CPU 和 GPU 的负载,引发设备发烫。

4. 电源消耗过大:
   - 过多的 drawcall 会大幅增加 CPU 和 GPU 的功耗,从而加大设备的总体电源消耗。
   - 持续高功耗会导致设备发烫,甚至可能引发电池过热的问题。

在移动设备上,drawcall 过高不仅会影响游戏的整体性能,还可能导致设备发烫的问题。这不仅会影响游戏体验,还可能造成设备损坏或电池安全隐患。因此,在移动游戏开发中,合理控制 drawcall 数量是非常重要的性能优化点。



##### 将素材打进同一个纹理集会减少drawcall 的原理是什么

将素材放在同一个纹理集中可以减少 drawcall 的原因主要有以下几个方面:

1. 减少纹理切换:
   - 每个 drawcall 都需要绑定对应的纹理才能进行渲染。
   - 如果使用多个小纹理,就需要在不同的 drawcall 中频繁切换纹理。
   - 而将多个小纹理合并到一个大纹理集中,就可以在同一个 drawcall 中使用同一个纹理,减少了纹理切换的开销。

2. 提高合批效率:
   - GPU 会尝试对使用相同纹理的 drawcall 进行合批处理,以提高渲染效率。
   - 如果使用多个小纹理,GPU 很难找到可以合批的 drawcall,因为每个 drawcall 都使用不同的纹理。
   - 而将多个小纹理合并到一个大纹理集中,就增加了 GPU 找到可以合批的 drawcall 的机会。

3. 减少 CPU 开销:
   - 每个 drawcall 都需要 CPU 来设置相关的渲染状态,包括纹理绑定。
   - 如果使用多个小纹理,就需要在不同的 drawcall 中频繁切换纹理绑定,增加了 CPU 的开销。
   - 而将多个小纹理合并到一个大纹理集中,就可以在同一个 drawcall 中使用同一个纹理绑定,减少了 CPU 的开销。

4. 优化内存使用:
   - 每个纹理都需要占用一定的显存空间。
   - 如果使用多个小纹理,就需要占用更多的显存空间。
   - 而将多个小纹理合并到一个大纹理集中,就可以减少显存的使用量,优化内存使用。

综上所述,将素材放在同一个纹理集中可以减少纹理切换、提高合批效率、减少 CPU 开销、优化内存使用等,从而有效降低 drawcall 的数量,提高整体的渲染性能。这是一种非常常见且有效的性能优化手段。


##### GPU 会尝试对使用相同纹理的 drawcall 进行合批处理,以提高渲染效率。 详细过程是什么？

好的,我来详细说明一下 GPU 如何进行合批渲染的过程,并以 Cocos2d-x Lua/C++ 为例给出具体的代码实现。

在 Cocos2d-x 中,合批渲染的过程主要分为以下几个步骤:

1. 渲染状态缓存（重点是渲染状态）
   - 在每个 drawcall 执行之前,Cocos2d-x 的渲染引擎会缓存当前的渲染状态,包括纹理、混合模式、变换矩阵等。
   - 这些渲染状态会作为一个"批次"的标识,用于后续的合批判断。

2. 合批判断
   - 当遇到下一个 drawcall 时,Cocos2d-x 的渲染引擎会比较当前的渲染状态与缓存的渲染状态是否一致。
   - 如果渲染状态一致,说明这两个 drawcall 可以进行合批处理。

3. 合批渲染
   - 如果两个 drawcall 的渲染状态一致,Cocos2d-x 的渲染引擎就会将它们合并成一个 drawcall 进行渲染。
   - 具体做法是将两个 drawcall 的顶点数据、纹理坐标等合并到同一个 VBO (Vertex Buffer Object) 中,然后使用一个 drawArrays 或 drawElements 命令来渲染。

下面是一个简单的 Cocos2d-x Lua 代码示例:

```lua
-- 创建3个 UI 元素
local element1 = cc.Sprite:create("element1.png")
local element2 = cc.Sprite:create("element2.png")
local element3 = cc.Sprite:create("element3.png")

-- 设置相同的渲染状态
element1:setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
element2:setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
element3:setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)

-- 将 UI 元素添加到场景中
element1:setPosition(100, 100)
element2:setPosition(200, 100)
element3:setPosition(300, 100)
scene:addChild(element1)
scene:addChild(element2)
scene:addChild(element3)
```

在这个例子中,3个 UI 元素使用了相同的渲染状态(混合模式)。当 Cocos2d-x 的渲染引擎遍历并绘制这些元素时,会发现它们的渲染状态一致,因此可以进行合批渲染:

1. 缓存第一个元素的渲染状态作为"批次"标识。
2. 遇到第二个元素时,发现渲染状态与缓存的一致,可以进行合批。
3. 将第一个和第二个元素的顶点数据、纹理坐标等合并到同一个 VBO 中。
4. 使用一个 drawArrays 或 drawElements 命令来渲染这个"合批"的 drawcall。
5. 重复步骤 2-4,直到遇到渲染状态不一致的元素。

这样做可以大幅减少 drawcall 的数量,提高整体的渲染性能。当然,实际的合批过程会更加复杂,需要考虑更多的渲染状态因素,但基本原理是相同的。


###### 问题：上述例子中"element1.png"、"element2.png"、"element3.png" 放在同一个plist 合图与分别是三张散图，都会进行合批吗？在上述合批的过程中两者有什么区别？

在上述例子中,如果 "element1.png"、"element2.png"、"element3.png" 分别是三张散图,与它们放在同一个 plist 合图中,在合批过程中会有以下区别:

1. 散图情况:
   - 每个 UI 元素使用的是不同的纹理,即使它们的渲染状态一致,GPU 也无法进行合批处理。
   - 因为每个 drawcall 都需要绑定不同的纹理,无法满足合批的条件。
   - 所以在这种情况下,即使渲染状态一致,也无法进行合批渲染。

2. 合图情况:
   - 当 "element1.png"、"element2.png"、"element3.png" 放在同一个 plist 合图中时,它们实际上是同一个纹理的不同区域。
   - 这种情况下,即使 UI 元素使用的是不同的纹理坐标,但它们最终都会绑定到同一个纹理上。
   - 因此,GPU 可以判断这些 drawcall 使用的是同一个纹理,满足合批的条件。
   - 于是 Cocos2d-x 的渲染引擎就可以将这些 drawcall 合并成一个 drawcall 进行渲染。

总的来说,使用合图可以大大提高合批的机会,从而减少 drawcall 的数量,提高整体的渲染性能。而如果使用散图,即使渲染状态一致,GPU 也无法进行合批,这会导致更多的 drawcall 和性能损耗。

因此,在游戏开发中,合理使用合图技术是一个非常重要的性能优化手段。通过将相关的资源合并到同一个纹理中,可以最大限度地提高 GPU 的合批效率,从而大幅提升游戏的整体渲染性能。


###### 问题：那么当"element1.png"、"element2.png" 处于plist合图1 ，而"element3.png"  处于合图2，"element3.png" 是不是不能进行合批你说得很对。如果 "element1.png"、"element2.png" 处于一个 plist 合图中,而 "element3.png" 处于另一个 plist 合图中,那么 "element3.png" 就无法与前两个元素进行合批渲染。

具体来说,在这种情况下:

1. "element1.png" 和 "element2.png" 可以进行合批渲染:
   - 因为它们位于同一个纹理集中,使用的是同一个纹理。
   - 只要渲染状态一致,GPU 就可以将它们合并成一个 drawcall 进行渲染。

2. "element3.png" 无法与前两个元素进行合批:
   - 因为 "element3.png" 使用的是另一个纹理集中的纹理。
   - 即使渲染状态一致,GPU 也无法将使用不同纹理的 drawcall 进行合批。

这种情况下,Cocos2d-x 的渲染引擎会分别为 "element1.png"、"element2.png" 和 "element3.png" 生成三个独立的 drawcall 进行渲染。

因此,如果想充分利用合批技术提升性能,不仅要确保资源放在同一个 plist 合图中,还需要尽量将相关的 UI 元素放在同一个合图中。这样可以最大限度地增加 GPU 进行合批渲染的机会,从而大幅减少 drawcall 的数量,提高整体的渲染性能。

## 合批
记录渲染状态：
主要就是纹理、混合模式
是的,在 Cocos2d-x 中,渲染引擎在执行每个 drawcall 之前,除了缓存纹理、混合模式、变换矩阵等,还会缓存以下一些重要的渲染状态:

1. 顶点属性:
   - 包括顶点位置、法线、纹理坐标等顶点数据。
   - 这些顶点属性决定了图形的几何形状和纹理映射。

2. 着色器程序:
   - 用于定义顶点和片元着色器的程序。
   - 着色器程序决定了图形的最终渲染效果。

3. 深度测试和深度写入状态:
   - 决定了图形在 Z 轴方向上的遮挡关系。

4. 裁剪状态:
   - 决定了图形在屏幕空间中的可见区域。

5. 光照模型:
   - 包括环境光、漫反射光、镜面反射光等光照参数。
   - 这些参数决定了图形的明暗效果。

6. 材质属性:
   - 包括颜色、纹理、反射率等材质参数。
   - 这些参数决定了图形的材质外观。

7. 渲染目标:
   - 决定了图形的渲染输出目标,比如屏幕缓冲区、离屏缓冲区等。

8. 其他状态:
   - 如线宽、点大小、多重采样等渲染状态。

Cocos2d-x 的渲染引擎会将这些渲染状态缓存下来,并在下一个 drawcall 执行时进行比较和判断,以确定是否可以进行合批渲染。只有当这些状态完全一致时,GPU 才能将多个 drawcall 合并成一个,从而提高渲染效率。

因此,合理管理和控制这些渲染状态是实现高效合批渲染的关键所在。开发者需要充分了解这些状态,并在设计和优化游戏渲染流程时予以重点考虑。