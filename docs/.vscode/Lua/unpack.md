# unpack pack 相关参数说明
| 格式字符 | 数据类型               | 描述                             |
|----------|------------------------|----------------------------------|
| `b`      | 有符号 8 位整数       | 范围：-128 到 127                |
| `B`      | 无符号 8 位整数       | 范围：0 到 255                   |
| `h`      | 有符号 16 位整数      | 范围：-32768 到 32767            |
| `H`      | 无符号 16 位整数      | 范围：0 到 65535                 |
| `l`      | 有符号 32 位整数      | 范围：-2147483648 到 2147483647  |
| `L`      | 无符号 32 位整数      | 范围：0 到 4294967295             |
| `f`      | 32 位浮点数           |                                  |
| `d`      | 64 位浮点数           |                                  |
| `s`      | 字符串                 | 以 NUL 结尾的字符串               |
| `p`      | 指针                   | 以 NUL 结尾的字符串，表示指针内容 |
| `c`      | 字符                   | 单个字符（8 位）                 |



在这段代码中，`">b"` 被用作 `pack` 函数的格式字符串，其作用是将一个有符号的 8 位整数（字节）打包为二进制格式。具体分析如下：

# 代码解析

```lua
function NetData:writeByte(byByte)
    local str = pack(">b", byByte)
    self:append(str)
    self._iSize = self._iSize + 1
end
```

#### 1. **`">b"` 的含义**
- **`>`**: 表示使用大端字节序（big-endian），即高位字节在前。
- **`b`**: 表示有符号的 8 位整数（signed char），范围为 -128 到 127。

#### 2. **`pack` 函数**
- `pack(">b", byByte)` 将 `byByte` 变量（一个有符号的 8 位整数）打包成二进制格式字符串。这个字符串可以用于网络传输或文件存储。

#### 3. **`self:append(str)`**
- `self:append(str)` 方法将打包后的二进制字符串 `str` 附加到 `NetData` 对象的某个内部数据结构中，通常是一个缓冲区，用于存储将要发送的数据。

#### 4. **`self._iSize = self._iSize + 1`**
- 这行代码更新 `NetData` 对象的 `_iSize` 属性，表示当前缓冲区中已经写入的字节数增加了 1。这对于管理数据大小和确保正确发送数据非常重要。

### 总结
使用 `">b"` 是为了确保以大端字节序打包有符号的 8 位整数，适用于网络传输等场景。整个 `writeByte` 方法的目的是将一个字节数据写入到数据缓冲区中，并更新相应的大小信息。




# 大端字节序与小端字节序
大端字节序（big-endian）和小端字节序（little-endian）是两种不同的字节序排列方式，用于在计算机内存中存储多字节数据（如整数、浮点数等）。下面是它们的定义及举例说明：

### 1. 大端字节序（Big-endian）
在大端字节序中，数据的高位字节存储在低地址处，低位字节存储在高地址处。也就是说，字节的顺序是从左到右，最重要的字节在前。

#### 例子
假设有一个 32 位整数 `0x12345678`，其字节表示为：
- 0x12
- 0x34
- 0x56
- 0x78

在大端字节序中，这个整数在内存中的存储顺序为：
```
地址   | 数据
-------|------
0x00  | 0x12
0x01  | 0x34
0x02  | 0x56
0x03  | 0x78
```

### 2. 小端字节序（Little-endian）
在小端字节序中，数据的低位字节存储在低地址处，高位字节存储在高地址处。也就是说，字节的顺序是从右到左，最重要的字节在最后。

#### 例子
同样以整数 `0x12345678` 为例，其字节表示为：
- 0x12
- 0x34
- 0x56
- 0x78

在小端字节序中，这个整数在内存中的存储顺序为：
```
地址   | 数据
-------|------
0x00  | 0x78
0x01  | 0x56
0x02  | 0x34
0x03  | 0x12
```

### 总结
- **大端字节序**: 高位字节在前，适用于网络协议（如 TCP/IP）。
- **小端字节序**: 低位字节在前，通常用于 x86 和 x86-64 架构的处理器。

这两种字节序在不同的计算机架构和网络协议中有不同的应用，了解它们有助于处理数据的读写和传输。